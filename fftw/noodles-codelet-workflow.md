# Running codelets on the fly

``` {.py file=codelets.py}
import subprocess
import re
import uuid

import numpy as np

from pathlib import (Path)
from ctypes import (cdll, c_void_p, c_ssize_t)
from collections import (namedtuple)

from noodles.run.threading.sqlite3 import run_parallel
from noodles import serial
import noodles

CodeletSignature = namedtuple("CodeletSignature", ["return_type", "arg_types"])

# JSON compatible config dictionary
default_config = {
    "compiler":       "g++",
    "compile_args":   ["-x", "c++", "-O3", "-include", "codelet.hh", "-shared"],
    "build_path":     "lib",
    "generator_path": "../genfft",
    "generator_name": "gen_{variant}.native"
}

codelet_signatures = {
    "twiddle": CodeletSignature(
        None, [c_void_p, c_void_p, c_void_p, c_ssize_t, c_ssize_t, c_ssize_t, c_ssize_t]),
    "notw":    CodeletSignature(
        None, [c_void_p, c_void_p, c_void_p, c_void_p, c_ssize_t, c_ssize_t,
               c_ssize_t, c_ssize_t, c_ssize_t])
}


def compile_command(config, target):
    """Generate compiler command.
    
    :param config: Configuration, see `default_config`
    :type config: `dict`
    :param target: Path to target
    :type target: `str` or `Path`
    :returns: command suitable for `subprocess.run`
    :rtype: list of `str`
    """
    return [config["compiler"]] + config["compile_args"] \
        + ["-o", str(target), "-"]


@noodles.schedule(store=True)
def generate_codelet(
        config, variant, *,
        n, compact=True, standalone=True,
        **kwargs):
    """Generate a codelet using one of the FFTW3 codelet generators.
    
    :param config: Configuration, see `default_config`
    :type config: `dict`
    :param variant: "notw" or "twiddle"
    :type variant: `str`
    :returns: code generated by the `genfft` program
    :rtype: `str`
    
    All other arguments are passed on to `genfft`. If the argument value has
    type `bool`, it is passed as a flag, otherwise the value is converted to
    a string and passed as argument.
    
    :param n: FFT radix
    :param compact: (flag) group variable declarations
    :param standalone: (flag) don't include FFTW3 boilerplate
    """
    kwargs["n"] = n
    kwargs["compact"] = compact
    kwargs["standalone"] = standalone

    def make_arg(name, value):
        if isinstance(value, bool):
            if value:
                return ["-" + name]
            else:
                return []
        else:
            return ["-" + name, str(value)]

    exe = Path(config["generator_path"]) \
        / config["generator_name"].format(variant=variant)
    command = sum(map(make_arg, kwargs.keys(), kwargs.values()), [str(exe)])
    result = subprocess.run(
        command, check=True, text=True, capture_output=True)
    return result.stdout


@noodles.schedule
def indent_code(source):
    """Call the `indent` utility to pretty-print C-code.
    
    :param source: C code
    :type source: `str`
    :returns: indented C code
    :rtype: `str`
    """
    result = subprocess.run(
        ["indent", "-nut"], check=True, text=True, input=source,
        capture_output=True)
    return result.stdout


@noodles.schedule
def declare_extern_c(source):
    """Change the function declaration to extern "C".
    
    :param source: C code
    :type source: `str`
    :returns: modified C code
    :rtype: `str`
    """
    return "\n".join(re.sub("^void", "extern \"C\" void", line)
                     for line in source.splitlines())


@noodles.schedule(store=True)
def build_shared_object(config, source):
    """Compile a C source into a shared object."""
    target = Path(config["build_path"]) / (uuid.uuid4().hex + ".so")
    target.parent.mkdir(exist_ok=True)
    subprocess.run(
        compile_command(config, target),
        check=True, text=True, input=source)
    return Path(target)

<<load-notw-codelet>>
<<load-twiddle-codelet>>


def run(wf):
    return run_parallel(wf, registry=serial.base, n_threads=4, db_file="lib/db", echo_log=False)


def generate_fft(config, variant, **kwargs):
    kwargs["name"] = "fft"
    code_p = indent_code(
        declare_extern_c(
            generate_codelet(config, variant, **kwargs)))
    so_p = build_shared_object(config, code_p)
    shared_object = run(so_p)

    if variant == "notw":
        return load_notw_codelet(
            shared_object, kwargs["name"], "float32", kwargs["n"])
    elif variant == "twiddle":
        return load_twiddle_codelet(
            shared_object, kwargs["name"], "float32", kwargs["n"])
    else:
        raise ValueError("Unknown FFT variant: " + variant)
```

## Testing

``` {.py file=fft.py}
from codelets import (
    generate_fft, default_config)
import numpy as np


fft16 = generate_fft(default_config, "notw", n=16)
fft4 = generate_fft(default_config, "notw", n=4)
fft5 = generate_fft(default_config, "notw", n=5)
fft3 = generate_fft(default_config, "notw", n=3)
fft2 = generate_fft(default_config, "notw", n=2)
twiddle4 = generate_fft(default_config, "twiddle", n=4)
twiddle3 = generate_fft(default_config, "twiddle", n=3)
twiddle5 = generate_fft(default_config, "twiddle", n=5)

def w(k, n):
    return np.exp(-2j * np.pi * k / n)


def make_twiddle(n1, n2):
    I1 = np.arange(n1)
    I2 = np.arange(n2)
    return w(I1[:,None] * I2[None,:], n1*n2).astype('complex64')


def fft_p16(x):
    yA = np.zeros_like(x).reshape([4,4])
    yB = yA.T
    z = np.zeros_like(x)
    fft4(x.reshape([4,4]).T, yA)
    W = make_twiddle(4, 4)
    yA *= W
    fft4(yB, z.reshape([4,4]).T)
    return z


def fft_p12(x):
    y = np.zeros_like(x).reshape([3, 4])
    z = np.zeros_like(x)

    fft4(x.reshape([4, 3]).T, y)
    W = make_twiddle(3, 4)
    y *= W
    fft3(y.T, z.reshape([3, 4]).T)
    return z


def fft_p15(x):
    y = np.zeros_like(x).reshape([5, 3])
    z = np.zeros_like(x)

    fft3(x.reshape([3, 5]).T, y)
    W = make_twiddle(5, 3)
    y *= W
    fft5(y.T, z.reshape([5, 3]).T)
    return z


def fft_t15(x):
    y = np.zeros_like(x).reshape([5, 3])
    fft3(x.reshape([3, 5]).T, y)
    W = make_twiddle(3, 5)
    twiddle5(y.T, W[:,1:])
    return y.flatten()


def fft_t12(x):
    y = np.zeros_like(x).reshape([4, 3])
    fft4(x.reshape([4, 3]).T, y.T)
    W = make_twiddle(4, 3)
    twiddle3(y, W[:,1:])
    return y.flatten()


x = np.arange(12, dtype='complex64')
x15 = np.arange(15, dtype='complex64')

np.set_printoptions(precision=3)
print(np.fft.fft(x))
print(fft_p12(x))
print(fft_t12(x))
print()
print(make_twiddle(4, 3))
print(make_twiddle(2,2))
print()
print("FFT 5 x 3")
print(np.fft.fft(x15))
print(fft_p15(x15))
print(fft_t15(x15))


```
