---
title: Interfacing FFTW codelets
author: Johan Hidding (NLeSC)
---

FFTW3 includes a generator for *codelets* that implement smallish FFT algorithms in C. This generator, called `genfft` is written in OCAML and generates code that is written if not in C, in a generator DSL consisting purely of macros. None of this is documented very well.

This is an attempt to run FFTW codelets outside the context of the larger FFTW library.

An example of `gen_twiddle` output, piped through `indent`:

```
/* Generated by: genfft/gen_twiddle.native -n 3 */

/*
 * This function contains 16 FP additions, 12 FP multiplications,
 * (or, 10 additions, 6 multiplications, 6 fused multiply/add),
 * 15 stack variables, 2 constants, and 12 memory accesses
 */
static void
unnamed (R * ri, R * ii, const R * W, stride rs, INT mb, INT me, INT ms)
{
  DK (KP866025403, +0.866025403784438646763723170752936183471402627);
  DK (KP500000000, +0.500000000000000000000000000000000000000000000);
  {
    INT m;
    for (m = mb, W = W + (mb * 4); m < me;
         m = m + 1, ri = ri + ms, ii = ii + ms, W =
         W + 4, MAKE_VOLATILE_STRIDE (6, rs))
      {
        E T1;
        E T18;
        E T6;
        E T14;
        E T11;
        E T15;
        E T12;
        E T17;
        T1 = ri[0];
        T18 = ii[0];
        {
          E T3;
          E T5;
          E T2;
          E T4;
          T3 = ri[WS (rs, 1)];
          T5 = ii[WS (rs, 1)];
          T2 = W[0];
          T4 = W[1];
          T6 = FMA (T2, T3, T4 * T5);
          T14 = FNMS (T4, T3, T2 * T5);
        }
        {
          E T8;
          E T10;
          E T7;
          E T9;
          T8 = ri[WS (rs, 2)];
          T10 = ii[WS (rs, 2)];
          T7 = W[2];
          T9 = W[3];
          T11 = FMA (T7, T8, T9 * T10);
          T15 = FNMS (T9, T8, T7 * T10);
        }
        T12 = T6 + T11;
        T17 = T14 + T15;
        ri[0] = T1 + T12;
        ii[0] = T17 + T18;
        {
          E T13;
          E T16;
          E T19;
          E T20;
          T13 = FNMS (KP500000000, T12, T1);
          T16 = KP866025403 * (T14 - T15);
          ri[WS (rs, 2)] = T13 - T16;
          ri[WS (rs, 1)] = T13 + T16;
          T19 = KP866025403 * (T11 - T6);
          T20 = FNMS (KP500000000, T17, T18);
          ii[WS (rs, 1)] = T19 + T20;
          ii[WS (rs, 2)] = T20 - T19;
        }
      }
  }
}

static const tw_instr twinstr[] = {
  {TW_FULL, 0, 3},
  {TW_NEXT, 1, 0}
};

static const ct_desc desc =
  { 3, "unnamed", twinstr, &GENUS, {10, 6, 6, 0}, 0, 0, 0 };

void X (codelet_unnamed) (planner * p)
{
  X (kdft_dit_register) (p, unnamed, &desc);
}
```

# Macro definitions

The macros are defined in `kernel/ifftw.h`. The top codelet include file is `dft/codelet-dft.h`. I will copy these definitions here in minimal form, for single precision floating points. The goal is just being able to compile the (non SIMD) codelets and see what they actually compute using Python and a `ctypes` interface.

``` {.c++ file=codelet.hh}
#include <cstddef>

<<real-types>>
<<integer-types>>
<<fused-arithmetic>>
<<array-indices>>
```

## Real types

``` {.c++ #real-types}
using R = float;
using E = R;

#define K(x) ((E) x)
#define DK(name, value) const E name = K(value)
```

## Integer types

These are used as strides and indices.

``` {.c++ #integer-types}
using INT = ptrdiff_t;
```

## Fused arithmetic

Many of these operations can be optimised, also known as fused multiply-accumulate operations. Variants on these are implemented as static inline functions.

``` {.c++ #fused-arithmetic}
inline E FMA(E a, E b, E c) { return a * b + c; }
inline E FMS(E a, E b, E c) { return a * b - c; }
inline E FNMA(E a, E b, E c) { return -a * b - c; }
inline E FNMS(E a, E b, E c) { return -a * b + c; }
```

## Array indices

A lot of the FFTW trickery involves fooling the compiler so that it does *not* try to optimise stuff. We will assume that the compiler is actually nice.

``` {.c++ #array-indices}
using stride = INT;

template <typename T>
inline INT WS(stride s, T i) { return s * i; }

template <typename NPtr, typename X>
inline constexpr INT MAKE_VOLATILE_STRIDE(NPtr nptr, X x) { return 0; }
```

## Boiler plate

The codelet has to declare its own structure using an instance of `ct_desc`. We don't need this boilerplate right now. We'll write an `awk` script to comment the boiler plate.

``` {.awk file=strip-boiler-plate.awk}
/static void/ { gsub("static void", "extern \"C\" void", $0 ) }
/static const tw_instr .*/, /.*};/ { printf "// " }
/static const ct_desc .*/, /.*};/ { printf "// " }
/void X\(codelet.*/, /}/ { printf "// " }
/static const kdft_desc.*/, /.*};/ { printf "// " }
1
```

This also changes the signature of the codelet to `extern "C" void` instead of `static void`. This allows us to load the codelet function from its symbol.

# Building a shared object

This `Makefile` calls `genfft`, filters the output through our Awk script, and adds indentation. The generated sources are compiled using `-include codelet.hh` to include the macro definitions and linked to a shared library.

``` {.makefile file=Makefile}
build_dir=build
compile=g++
link=g++

codelet_dir=build
codelet_name=fft
codelet_cflags=-fpic -include codelet.hh
codelet_ldflags=-shared

.PHONY: clean all

## prevent intermediate files from being deleted
.SECONDARY:

all:	$(build_dir)/twiddle-7.gen.so \
	$(build_dir)/notw-7.gen.so

$(codelet_dir)/%.gen.cc : Makefile strip-boiler-plate.awk
	@mkdir -p $(@D)
	variant=$(word 1, $(subst -, ,$*)); \
	radix=$(word 2, $(subst -, ,$*)); \
	../genfft/gen_$${variant}.native -n $${radix} -name $(codelet_name) \
	| awk -f strip-boiler-plate.awk \
	| indent > $@

$(build_dir)/%.gen.o : $(codelet_dir)/%.gen.cc codelet.hh
	@mkdir -p $(@D)
	$(compile) $(codelet_cflags) -c $< -o $@

$(build_dir)/%.gen.so : $(build_dir)/%.gen.o
	@mkdir -p $(@D)
	$(link) $^ $(codelet_ldflags) -o $@

clean:
	-rm -rf $(build_dir)
```

# Running codelets from Python

Now we'll run the transform using `ctypes` and `numpy`.

``` {.py file=run-codelet.py}
import numpy as np
from ctypes import (cdll, c_void_p, c_ssize_t)
from collections import (namedtuple)

<<codelet-signatures>>
<<load-codelet>>

if __name__ == "__main__":
    <<run-main>>
```

## Signatures

Codelets from different generators have different signatures. The `notw` code seems to be the most *vanilla* fft. It takes pointers to real and imaginary input and output arrays (four in total), two strides, and a set of numbers indicating the layout of multiple FFTs to be performed. Other codelets seem to have similar signatures.

If we look at the output for `twiddle` codelets, we see that only input pointers are taken. Is the FFT computed in place? The third pointer argument points to an array of twiddle numbers. This can be usefull when composing to larger FFTs.

``` {.py #codelet-signatures}
CodeletSignature = namedtuple("CodeletSignature", ["return_type", "arg_types"])

codelet_signatures = {
    "twiddle": CodeletSignature(
        None, [c_void_p, c_void_p, c_void_p, c_ssize_t, c_ssize_t, c_ssize_t]),
    "notw":    CodeletSignature(
        None, [c_void_p, c_void_p, c_void_p, c_void_p, c_ssize_t, c_ssize_t,
               c_ssize_t, c_ssize_t, c_ssize_t])
}
```

## Loading a codelet

``` {.py #load-codelet}
def load_codelet(shared_object, function_name, signature, dtype, radix):
    <<load-function>>
    <<make-wrapper>>
    return fft_notw
```

First we load the `.so` file

``` {.py #load-function}
lib = cdll.LoadLibrary(shared_object)
fun = getattr(lib, function_name)
fun.argtypes = codelet_signatures[signature].arg_types
dtype = np.dtype(dtype)
```

Using the `notw` signature we can implement a wrapper for NumPy arrays

``` {.py #make-wrapper}
def fft_notw(input_array, output_array):
    assert(input_array.ndim == 1)
    assert(output_array.ndim == 1)
    assert(input_array.size == radix)
    assert(output_array.size == radix)
    if dtype == 'float32':
        assert(input_array.dtype == 'complex64')
        assert(output_array.dtype == 'complex64')
    if dtype == 'float64':
        assert(input_array.dtype == 'complex128')
        assert(output_array.dtype == 'complex128')

    float_size = dtype.itemsize
    input_stride = input_array.strides[0] / float_size
    output_stride = output_array.strides[0] / float_size
    fun(input_array.ctypes.data, input_array.ctypes.data + float_size,
        output_array.ctypes.data, output_array.ctypes.data + float_size,
        input_stride, output_stride, 1, 0, 0)
```

## Main body

``` {.py #run-main}
fft7 = load_codelet("build/notw-7.gen.so", "fft", "notw", "float32", 7)
x = np.arange(7, dtype='complex64')
y = np.zeros_like(x)
fft7(x, y)
print(y)
print(np.fft.fft(x))
```

