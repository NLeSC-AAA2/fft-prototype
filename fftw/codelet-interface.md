---
title: Interfacing FFTW codelets
author: Johan Hidding (NLeSC)
---

FFTW3 includes a generator for *codelets* that implement smallish FFT algorithms in C. This generator, called `genfft` is written in OCAML and generates code that is written if not in C, in a generator DSL consisting purely of macros. None of this is documented very well.

This is an attempt to run FFTW codelets outside the context of the larger FFTW library.

An example of `gen_twiddle` output, piped through `indent -nut`:

``` {.c}
/* Generated by: ./gen_notw.native -n 3 -standalone -compact -rader-min 3 */

/*
 * This function contains 12 FP additions, 4 FP multiplications,
 * (or, 10 additions, 2 multiplications, 2 fused multiply/add),
 * 15 stack variables, 2 constants, and 12 memory accesses
 */
void
unnamed (const R * ri, const R * ii, R * ro, R * io, stride is, stride os,
         INT v, INT ivs, INT ovs)
{
  DK (KP500000000, +0.500000000000000000000000000000000000000000000);
  DK (KP866025403, +0.866025403784438646763723170752936183471402627);
  {
    INT i;
    for (i = v; i > 0;
         i = i - 1, ri = ri + ivs, ii = ii + ivs, ro = ro + ovs, io =
         io + ovs, MAKE_VOLATILE_STRIDE (12, is), MAKE_VOLATILE_STRIDE (12,
                                                                        os))
      {
        E T1, T9, T4, Tc, T8, Ta, T5, Tb;
        T1 = ri[0];
        T9 = ii[0];
        {
          E T2, T3, T6, T7;
          T2 = ri[WS (is, 1)];
          T3 = ri[WS (is, 2)];
          T4 = T2 + T3;
          Tc = KP866025403 * (T2 - T3);
          T6 = ii[WS (is, 1)];
          T7 = ii[WS (is, 2)];
          T8 = KP866025403 * (T6 - T7);
          Ta = T6 + T7;
        }
        ro[0] = T1 + T4;
        io[0] = T9 + Ta;
        T5 = FNMS (KP500000000, T4, T1);
        ro[WS (os, 2)] = T5 - T8;
        ro[WS (os, 1)] = T5 + T8;
        Tb = FNMS (KP500000000, Ta, T9);
        io[WS (os, 1)] = Tb - Tc;
        io[WS (os, 2)] = Tc + Tb;
      }
  }
}
```

# Macro definitions

The macros are defined in `kernel/ifftw.h`. The top codelet include file is `dft/codelet-dft.h`. I will copy these definitions here in minimal form, for single precision floating points. The goal is just being able to compile the (non SIMD) codelets and see what they actually compute using Python and a `ctypes` interface.

``` {.c++ file=codelet.hh}
#include <cstddef>

<<real-types>>
<<integer-types>>
<<fused-arithmetic>>
<<array-indices>>
```

## Real types

``` {.c++ #real-types}
using R = float;
using E = R;

#define K(x) ((E) x)
#define DK(name, value) const E name = K(value)
```

## Integer types

These are used as strides and indices.

``` {.c++ #integer-types}
using INT = ptrdiff_t;
```

## Fused arithmetic

Many of these operations can be optimised, also known as fused multiply-accumulate operations. Variants on these are implemented as static inline functions.

``` {.c++ #fused-arithmetic}
inline E FMA(E a, E b, E c) { return a * b + c; }
inline E FMS(E a, E b, E c) { return a * b - c; }
inline E FNMA(E a, E b, E c) { return -a * b - c; }
inline E FNMS(E a, E b, E c) { return -a * b + c; }
```

## Array indices

A lot of the FFTW trickery involves fooling the compiler so that it does *not* try to optimise stuff. We will assume that the compiler is actually nice.

``` {.c++ #array-indices}
using stride = INT;

template <typename T>
inline INT WS(stride s, T i) { return s * i; }

template <typename NPtr, typename X>
inline constexpr INT MAKE_VOLATILE_STRIDE(NPtr nptr, X x) { return 0; }
```

## Boiler plate

The codelet has to declare its own structure using an instance of `ct_desc`. We don't need this boilerplate right now. We'll write an `awk` script to comment the boiler plate.

``` {.awk file=strip-boiler-plate.awk}
/void/ { gsub("void", "extern \"C\" void", $0 ) }
1
```

This also changes the signature of the codelet to `extern "C" void` instead of `static void`. This allows us to load the codelet function from its symbol.

# Building a shared object

This `Makefile` calls `genfft`, filters the output through our Awk script, and adds indentation. The generated sources are compiled using `-include codelet.hh` to include the macro definitions and linked to a shared library.

``` {.makefile file=Makefile}
build_dir=build
compile=g++
link=g++

codelet_dir=build
codelet_name=fft
codelet_cflags=-O3 -fpic -include codelet.hh
codelet_ldflags=-shared

.PHONY: clean all

## prevent intermediate files from being deleted
.SECONDARY:

all:	$(build_dir)/twiddle-7.gen.so \
	$(build_dir)/notw-7.gen.so \
	$(build_dir)/notw-21.gen.so

$(codelet_dir)/%.gen.cc : Makefile strip-boiler-plate.awk
	@mkdir -p $(@D)
	variant=$(word 1, $(subst -, ,$*)); \
	radix=$(word 2, $(subst -, ,$*)); \
	../genfft/gen_$${variant}.native -n $${radix} -name $(codelet_name) \
	    -standalone -compact -rader-min 17 -circular-min 3 \
	| awk -f strip-boiler-plate.awk \
	| indent -nut > $@

$(build_dir)/%.gen.o : $(codelet_dir)/%.gen.cc codelet.hh
	@mkdir -p $(@D)
	$(compile) $(codelet_cflags) -c $< -o $@

$(build_dir)/%.gen.so : $(build_dir)/%.gen.o
	@mkdir -p $(@D)
	$(link) $^ $(codelet_ldflags) -o $@

clean:
	-rm -rf $(build_dir)
```

# Running codelets from Python

Now we'll run the transform using `ctypes` and `numpy`.

``` {.py file=test-codelets.py}
import numpy as np
from ctypes import (cdll, c_void_p, c_ssize_t)
from collections import (namedtuple)

<<codelet-signatures>>
<<load-notw-codelet>>

if __name__ == "__main__":
    <<run-main>>
```

## Signatures

Codelets from different generators have different signatures. The `notw` code seems to be the most *vanilla* fft. It takes pointers to real and imaginary input and output arrays (four in total), two strides, and a set of numbers indicating the layout of multiple FFTs to be performed. Other codelets seem to have similar signatures.

If we look at the output for `twiddle` codelets, we see that only input pointers are taken. Is the FFT computed in place? The third pointer argument points to an array of twiddle numbers. This can be usefull when composing to larger FFTs.

``` {.python #codelet-signatures}
CodeletSignature = namedtuple("CodeletSignature", ["return_type", "arg_types"])

codelet_signatures = {
    "twiddle": CodeletSignature(
        None, [c_void_p, c_void_p, c_void_p, c_ssize_t, c_ssize_t, c_ssize_t]),
    "notw":    CodeletSignature(
        None, [c_void_p, c_void_p, c_void_p, c_void_p, c_ssize_t, c_ssize_t,
               c_ssize_t, c_ssize_t, c_ssize_t])
}
```

## Loading a codelet

``` {.python #load-notw-codelet}
def load_notw_codelet(shared_object, function_name, dtype, radix):
    signature = codelet_signatures["notw"]
    <<load-function>>
    <<make-wrapper>>
    return fft_notw
```

First we load the `.so` file

``` {.python #load-function}
lib = cdll.LoadLibrary(shared_object)
fun = getattr(lib, function_name)
fun.argtypes = signature.arg_types
dtype = np.dtype(dtype)
```

Using the `notw` signature we can implement a wrapper for NumPy arrays

``` {.python #input-strides}
float_size = dtype.itemsize
input_strides = [s // float_size for s in input_array.strides]
if input_array.ndim == 1:
    n = 1
else:
    n = input_array.shape[0]
```

``` {.python #make-wrapper}
def fft_notw(input_array, output_array):
    <<notw-assertions>>
    <<input-strides>>
    output_strides = [s // float_size for s in output_array.strides]

    fun(input_array.ctypes.data, input_array.ctypes.data + float_size,
        output_array.ctypes.data, output_array.ctypes.data + float_size,
        input_strides[-1], output_strides[-1], n,
        input_strides[0], output_strides[0])
```

To guard against errors we have to make some assertions. These could be disabled if performance becomes an issue, but I don't think this code will ever be used in that way.

``` {.python #notw-assertions}
assert(input_array.shape == output_array.shape)
if dtype == 'float32':
    assert(input_array.dtype == 'complex64')
    assert(output_array.dtype == 'complex64')
if dtype == 'float64':
    assert(input_array.dtype == 'complex128')
    assert(output_array.dtype == 'complex128')
```

``` {.python #shape-assertions}
if input_array.ndim == 1:
    assert(input_array.size == radix)
elif input_array.ndim == 2:
    assert(input_array.shape[1] == radix)
else:
    raise ValueError("Expecting array of dimension 1 or 2.")
```

## Twiddle codelet

``` {.python #load-twiddle-codelet}
def load_twiddle_codelet(shared_object, function_name, dtype, radix):
    signature = codelet_signatures["twiddle"]
    <<load-function>>

    def fft_twiddle(input_array, twiddle_factors):
        if dtype == 'float32':
            assert(input_array.dtype == 'complex64')
        if dtype == 'float64':
            assert(input_array.dtype == 'complex128')
        <<shape-assertions>>

        n_w = radix - 1
        assert(input_array.dtype == twiddle_factors.dtype)
        if input_array.ndim == 1:
            assert(twiddle_factors.shape == (n_w,))
        else:
            assert(twiddle_factors.shape == (input_array.shape[0], n_w))

        <<input-strides>>
        fun(input_array.ctypes.data, input_array.ctypes.data + float_size,
            twiddle_factors.ctypes.data,
            input_strides[-1], 0, n, input_strides[0])

    return fft_twiddle
```

## Using twiddles

If we compare the radix-2 twiddle codelet

``` {.c}
void
unnamed (R * ri, R * ii, const R * W, stride rs, INT mb, INT me, INT ms)
{
  {
    INT m;
    for (m = mb, W = W + (mb * 2); m < me;
         m = m + 1, ri = ri + ms, ii = ii + ms, W =
         W + 2, MAKE_VOLATILE_STRIDE (4, rs))
      {
        E T1, T8, T6, T7;
        T1 = ri[0];
        T8 = ii[0];
        {
          E T3, T5, T2, T4;
          T3 = ri[WS (rs, 1)];
          T5 = ii[WS (rs, 1)];
          T2 = W[0];
          T4 = W[1];
          T6 = FMA (T2, T3, T4 * T5);
          T7 = FNMS (T4, T3, T2 * T5);
        }
        ri[WS (rs, 1)] = T1 - T6;
        ii[WS (rs, 1)] = T8 - T7;
        ri[0] = T1 + T6;
        ii[0] = T7 + T8;
      }
  }
}
```

$$\begin{aligned}
ro_0 &= ri_0 + w_0 * ri_1 + w_1 * ii_1 \\
ro_1 &= ri_0 - w_0 * ri_1 - w_1 * ii_1 \\
io_0 &= ii_0 - w_1 * ri_1 + w_0 * ii_1 \\
io_1 &= ii_0 + w_1 * ri_1 - w_0 * ii_1
\end{aligned}$$

(check signs) having,

$$w_n^k z_k = (a + ib) (x + iy) = ax - by + i(bx + ay)$$

Are the weights conjugated?

$$\begin{aligned}
o_0 &= i_0 + w_0^* i_1\\
o_1 &= i_0 - w_1^* i_1
\end{aligned}

with the radix-2 non-twiddle codelet

``` {.c}
void
unnamed (const R * ri, const R * ii, R * ro, R * io, stride is, stride os,
         INT v, INT ivs, INT ovs)
{
  {
    INT i;
    for (i = v; i > 0;
         i = i - 1, ri = ri + ivs, ii = ii + ivs, ro = ro + ovs, io =
         io + ovs, MAKE_VOLATILE_STRIDE (8, is), MAKE_VOLATILE_STRIDE (8, os))
      {
        E T1, T2, T3, T4;
        T1 = ri[0];
        T2 = ri[WS (is, 1)];
        ro[WS (os, 1)] = T1 - T2;
	
        ro[0] = T1 + T2;
        T3 = ii[0];
        T4 = ii[WS (is, 1)];
        io[WS (os, 1)] = T3 - T4;
        io[0] = T3 + T4;
      }
  }
}
```

We may learn how twiddle factors are incorporated.

$$\begin{aligned}
ro_0 &= ri_0 + ri_1 \\
ro_1 &= ri_0 - ri_1 \\
io_0 &= ii_0 + ii_1 \\
io_1 &= ii_0 - ii_1
\end{aligned}$$

or

$$\begin{aligned}
o_0 &= i_0 + i_1 \\
o_1 &= i_0 - i_1 \\
$$\end{aligned}

We know that the input values need to be multiplied with twiddle factors, but the twiddle for $i_0$ is always 1.


## Main body

``` {.python #run-main}
fft7 = load_notw_codelet("build/notw-7.gen.so", "fft", "float32", 7)
x = np.arange(7, dtype='complex64')
y = np.zeros_like(x)
fft7(x, y)
print(y)
print(np.fft.fft(x))
```

